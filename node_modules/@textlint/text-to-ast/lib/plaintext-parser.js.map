{"version":3,"sources":["../src/plaintext-parser.js"],"names":["Syntax","require","parseLine","lineText","lineNumber","startIndex","type","Str","raw","value","range","length","loc","start","line","column","end","createEndedBRNode","prevNode","lineBreakText","Break","createBRNode","createParagraph","nodes","firstNode","lastNode","Paragraph","map","node","join","children","splitTextByLine","text","LINEBREAKE_MARK_PATTERN","results","match","prevMatchIndex","exec","slicedText","slice","index","push","lineBreak","parse","textLineByLine","lastLineIndex","isLastEmptyLine","isEmptyLine","reduce","result","currentLine","emptyBreakNode","strNode","paragraph","breakNode","lastLine","undefined","Document","module","exports"],"mappings":"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","file":"plaintext-parser.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst Syntax = require(\"./plaintext-syntax\");\n\nfunction parseLine(lineText, lineNumber, startIndex) {\n    // Inline Node have `value`. It it not part of TxtNode.\n    // TODO: https://github.com/textlint/textlint/issues/141\n    return {\n        type: Syntax.Str,\n        raw: lineText,\n        value: lineText,\n        range: [startIndex, startIndex + lineText.length],\n        loc: {\n            start: {\n                line: lineNumber,\n                column: 0\n            },\n            end: {\n                line: lineNumber,\n                column: lineText.length\n            }\n        }\n    };\n}\n\n/**\n * create BreakNode next to StrNode\n * @param {TxtNode} prevNode previous node from BreakNode\n */\nfunction createEndedBRNode(prevNode, lineBreakText) {\n    return {\n        type: Syntax.Break,\n        raw: lineBreakText,\n        value: lineBreakText,\n        range: [prevNode.range[1], prevNode.range[1] + lineBreakText.length],\n        loc: {\n            start: {\n                line: prevNode.loc.end.line,\n                column: prevNode.loc.end.column\n            },\n            end: {\n                line: prevNode.loc.end.line,\n                column: prevNode.loc.end.column + lineBreakText.length\n            }\n        }\n    };\n}\n\n/**\n * create BreakNode next to StrNode\n */\nfunction createBRNode(lineNumber, startIndex) {\n    return {\n        type: Syntax.Break,\n        raw: \"\\n\",\n        range: [startIndex, startIndex + 1],\n        loc: {\n            start: {\n                line: lineNumber,\n                column: 0\n            },\n            end: {\n                line: lineNumber,\n                column: 1\n            }\n        }\n    };\n}\n\n/**\n * create paragraph node from TxtNodes\n * @param {[TxtNode]} nodes\n * @returns {TxtNode} Paragraph node\n */\nfunction createParagraph(nodes) {\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    return {\n        type: Syntax.Paragraph,\n        raw: nodes\n            .map(function(node) {\n                return node.raw;\n            })\n            .join(\"\"),\n        range: [firstNode.range[0], lastNode.range[1]],\n        loc: {\n            start: {\n                line: firstNode.loc.start.line,\n                column: firstNode.loc.start.column\n            },\n            end: {\n                line: lastNode.loc.end.line,\n                column: lastNode.loc.end.column\n            }\n        },\n        children: nodes\n    };\n}\n\nfunction splitTextByLine(text) {\n    const LINEBREAKE_MARK_PATTERN = /\\r?\\n/g;\n    const results = [];\n    let match = null;\n    let prevMatchIndex = 0;\n    while ((match = LINEBREAKE_MARK_PATTERN.exec(text)) !== null) {\n        const slicedText = text.slice(prevMatchIndex, match.index);\n        results.push({\n            text: prevMatchIndex === match.index ? \"\" : slicedText,\n            lineBreak: match[0]\n        });\n        prevMatchIndex = match.index + match[0].length;\n    }\n    if (text.length !== prevMatchIndex) {\n        results.push({\n            text: text.slice(prevMatchIndex, text.length),\n            lineBreak: null\n        });\n    }\n    return results;\n}\n\n/**\n * parse text and return ast mapped location info.\n * @param {string} text\n * @returns {TxtNode}\n */\nfunction parse(text) {\n    const textLineByLine = splitTextByLine(text);\n    // it should be alternately Str and Break\n    let startIndex = 0;\n    const lastLineIndex = textLineByLine.length - 1;\n    const isLastEmptyLine = (line, index) => {\n        return index === lastLineIndex && line.text === \"\";\n    };\n    const isEmptyLine = (line, index) => {\n        return index !== lastLineIndex && line.text === \"\";\n    };\n    const children = textLineByLine.reduce(function(result, currentLine, index) {\n        const lineNumber = index + 1;\n        if (isLastEmptyLine(currentLine, index)) {\n            return result;\n        }\n        // \\n\n        if (isEmptyLine(currentLine, index)) {\n            const emptyBreakNode = createBRNode(lineNumber, startIndex);\n            startIndex += emptyBreakNode.raw.length;\n            result.push(emptyBreakNode);\n            return result;\n        }\n\n        // (Paragraph > Str) -> Br?\n        const strNode = parseLine(currentLine.text, lineNumber, startIndex);\n        const paragraph = createParagraph([strNode]);\n        startIndex += paragraph.raw.length;\n        result.push(paragraph);\n        // add Break node with actual line break value\n        // It should support CRLF\n        // https://github.com/textlint/textlint/issues/656\n        if (currentLine.lineBreak !== null) {\n            const breakNode = createEndedBRNode(paragraph, currentLine.lineBreak);\n            startIndex += breakNode.raw.length;\n            result.push(breakNode);\n        }\n        return result;\n    }, []);\n    const lastLine = textLineByLine[textLineByLine.length - 1];\n    if (lastLine === undefined) {\n        return {\n            type: Syntax.Document,\n            raw: \"\",\n            range: [0, 0],\n            loc: {\n                start: {\n                    line: 1,\n                    column: 0\n                },\n                end: {\n                    line: 1,\n                    column: 0\n                }\n            },\n            children\n        };\n    }\n    return {\n        type: Syntax.Document,\n        raw: text,\n        range: [0, text.length],\n        loc: {\n            start: {\n                line: 1,\n                column: 0\n            },\n            end:\n                // if Last Line has line break\n                lastLine.lineBreak !== null\n                    ? {\n                          line: textLineByLine.length + 1,\n                          column: 0\n                      }\n                    : {\n                          line: textLineByLine.length,\n                          column: lastLine.text.length\n                      }\n        },\n        children\n    };\n}\n\nmodule.exports = parse;\n"]}